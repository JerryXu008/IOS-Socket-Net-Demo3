/*

===== IMPORTANT =====

This is sample code demonstrating API, technology or techniques in development.
Although this sample code has been reviewed for technical accuracy, it is not
final. Apple is supplying this information to help you plan for the adoption of
the technologies and programming interfaces described herein. This information
is subject to change, and software implemented based on this sample code should
be tested with final operating system software and final documentation. Newer
versions of this sample code may be provided with future seeds of the API or
technology. For information about updates to this and other developer
documentation, view the New & Updated sidebars in subsequent documentation
seeds.

=====================

File: TCPService.m
Abstract: Convenience class that acts as a controller for a listening TCP port
that accepts incoming connections.

Version: 1.1

Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc.
("Apple") in consideration of your agreement to the following terms, and your
use, installation, modification or redistribution of this Apple software
constitutes acceptance of these terms.  If you do not agree with these terms,
please do not use, install, modify or redistribute this Apple software.

In consideration of your agreement to abide by the following terms, and subject
to these terms, Apple grants you a personal, non-exclusive license, under
Apple's copyrights in this original Apple software (the "Apple Software"), to
use, reproduce, modify and redistribute the Apple Software, with or without
modifications, in source and/or binary forms; provided that if you redistribute
the Apple Software in its entirety and without modifications, you must retain
this notice and the following text and disclaimers in all such redistributions
of the Apple Software.
Neither the name, trademarks, service marks or logos of Apple Inc. may be used
to endorse or promote products derived from the Apple Software without specific
prior written permission from Apple.  Except as expressly stated in this notice,
no other rights or licenses, express or implied, are granted by Apple herein,
including but not limited to any patent rights that may be infringed by your
derivative works or by other works in which the Apple Software may be
incorporated.

The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
COMBINATION WITH YOUR PRODUCTS.

IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR
DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF
CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF
APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Copyright (C) 2008 Apple Inc. All Rights Reserved.

*/

#import <unistd.h>
#import <netinet/in.h>

#import "TCPService.h"
#import "NetUtilities.h"
#import "Networking_Internal.h"

//FUNCTIONS:
//socket回调函数，当有连接请求的时候，调用他
//参数类型： 参数一：触发了这个回调的socket本身  参数二：触发这个回调的事件类型  参数三：请求连接的远端设备的地址  参数四：它根据回调事件的不同，它代表的东西也不同，如果这个是连接失败回调事件，那它就代表一个错误代码的指针，
//如果是连接成功的回调事件，它就是一个Socket指针，如果是数据回调事件，这就是包含这些数据的指针，其它情况下它是NULL的 参数五：创建socket的时候用的那个CFSocketContext结构的info成员
static void _AcceptCallBack(CFSocketRef socket, CFSocketCallBackType type, CFDataRef address, const void* data, void* info)
{
	NSAutoreleasePool*		localPool = [NSAutoreleasePool new];
	TCPService*				service = (TCPService*)info; //本类
	
	if(kCFSocketAcceptCallBack == type)  //data为新创建的socket，用于连接二者
	[service handleNewConnectionWithSocket:*(CFSocketNativeHandle*)data fromRemoteAddress:(CFDataGetLength(address) >= sizeof(struct sockaddr) ? (const struct sockaddr*)CFDataGetBytePtr(address) : NULL)];
	
	[localPool release];
}

//CLASS IMPLEMENTATION:

@implementation TCPService

@synthesize running=_running;

- (id) initWithPort:(UInt16)port
{
	if((self = [super init]))
	_port = port;
	
	return self;
}

- (void) dealloc
{
	[self stop];
	
	[super dealloc];
}
//参数一：新创建的socket，参数二：远端的地址
- (void) handleNewConnectionWithSocket:(NSSocketNativeHandle)socket fromRemoteAddress:(const struct sockaddr*)address
{
	close(socket);
	/*_cmd的使用：和self一样，_cmd会隐式传递到每个方法，其中包含用来调用当前方法的选择器，就是调用自身
   //doseNotRecognizeSelector :
    // 苹果官方文档的解释：一个选择器,该选择器标识一个方法未被接收者执行或认可。
  运行时每当一个对象接收到消息时系统调用这个方法,它不能回复或转发。这种方法会产生一个NSInvalidArgumentException,并生成一个错误消息。
变量是一个隐藏的_cmd参数传递给每一个方法,是当前选择器;在本例中,它能够识别的选择符复制方法。这段代码可防止子类的实例从应对复制消息或超类从转发复制消息虽然respondsToSelector:仍将报告,接收方可以访问一个复制方法。

如果你覆盖这个方法,您必须调用超或提高一个NSInvalidArgumentException异常在结束时,您的实现。换句话说,这个方法必须不返回正常;它必须总是导致一个异常被抛出。
     */
  //这么做的目的就是让子类重写他
	[self doesNotRecognizeSelector:_cmd];
}
//新建一个socket，并让他监听端口,并把地址保存到了_localAddress
- (BOOL) startUsingRunLoop:(NSRunLoop*)runLoop
{
    CFSocketContext				socketCtxt = {0, self, NULL, NULL, NULL};
	int							yes = 1;
	struct sockaddr_in			addr4;
	CFRunLoopSourceRef			source;
	socklen_t					length;
	
	if(_runLoop)
	return NO;
	_runLoop = runLoop;
	if(!_runLoop)
	return NO;
	[_runLoop retain]; //retain一次，因为这里可能随时释放，不保存的话就把main主线程的运行循环释放啦
	
	_ipv4Socket = CFSocketCreate(kCFAllocatorDefault, PF_INET, SOCK_STREAM, IPPROTO_TCP, kCFSocketAcceptCallBack, (CFSocketCallBack)&_AcceptCallBack, &socketCtxt);
	if(!_ipv4Socket) {
		[self stop];
		return NO;
	}
	setsockopt(CFSocketGetNative(_ipv4Socket), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
	
	
	bzero(&addr4, sizeof(addr4));
	addr4.sin_len = sizeof(addr4);
	addr4.sin_family = AF_INET;
	addr4.sin_port = htons(_port);
	addr4.sin_addr.s_addr = htonl(INADDR_ANY); //NOTE: INADDR_ANY is defined as a host-endian constant, so it should be byte swapped
	if(CFSocketSetAddress(_ipv4Socket, (CFDataRef)[NSData dataWithBytes:&addr4 length:sizeof(addr4)]) != kCFSocketSuccess) {
		[self stop]; //停止一系列操作
		return NO;
	}
	length = sizeof(struct sockaddr_in);
	_localAddress = malloc(length); //本地地址
	if(getsockname(CFSocketGetNative(_ipv4Socket), _localAddress, &length) < 0) //把端口的地址写入到哦localAddress中
	[NSException raise:NSInternalInconsistencyException format:@"Unable to retrieve socket address"];
	
	//创建源并加入到运行循环中
	source = CFSocketCreateRunLoopSource(kCFAllocatorDefault, _ipv4Socket, 0);
	CFRunLoopAddSource([_runLoop getCFRunLoop], source, kCFRunLoopCommonModes);
   //运行循环会保存，所以这里释放	
   CFRelease(source);
	
	//循环正在监听
	_running = YES;
	
	return YES;
}
//[self.server enableBonjourWithDomain:@"local" applicationProtocol:@"PictureThrow" name:[self hostname]];
//初始化一个服务
- (BOOL) enableBonjourWithDomain:(NSString*)domain applicationProtocol:(NSString*)protocol name:(NSString*)name
{
	protocol = [TCPConnection bonjourTypeFromIdentifier:protocol];
	if(![domain length])
	domain = @""; //Will use default Bonjour registration doamins, typically just ".local"
	if(![name length])
	name = @""; //Will use default Bonjour name, e.g. the name assigned to the device in iTunes
	
	if(!protocol || !_running)
	return NO;
	//分配要发布的服务
	_netService = [[NSNetService alloc] initWithDomain:domain type:protocol name:name port:[self localPort]];
	if(_netService == NULL)
	return NO;
	//加入到运行循环
	[_netService scheduleInRunLoop:_runLoop forMode:NSRunLoopCommonModes];
  //发布服务	
   [_netService publish];
	[_netService setDelegate:self];
	
	return YES;
}
//发布成功的回调函数
- (void)netServiceDidPublish:(NSNetService *)sender
{
	assert(sender == _netService);
	NSLog(@"%s", _cmd);
}
//发布失败的回调函数
- (void)netService:(NSNetService *)sender didNotPublish:(NSDictionary *)errorDict
{
	assert(sender == _netService);
	NSLog(@"%s", _cmd);
}
//服务是否存在
- (BOOL) isBonjourEnabled
{
	return (_netService ? YES : NO);
}
//停止服务。使服务变得无效
- (void) disableBonjour
{
	if(_netService) {
		[_netService stop];
		[_netService removeFromRunLoop:_runLoop forMode:NSRunLoopCommonModes];
		[_netService release];
		_netService = nil;
	}
}
//看看停止方法的一系列操作
- (void) stop
{
	_running = NO;
	
	[self disableBonjour]; //是服务无效
	
	if(_ipv4Socket) {//是端口无效
		CFSocketInvalidate(_ipv4Socket);
		CFRelease(_ipv4Socket);
		_ipv4Socket = NULL;
	}
	if(_runLoop) {  //使运行循环无效，之前有过retain，所以可以大胆的释放就行，
		[_runLoop release];
		_runLoop = nil;
	}
	if(_localAddress) {//释放本地地址
		free(_localAddress);
		_localAddress = NULL;
	}
}
//返回绑定的端口，木有绑定socekt的话就返回0
- (UInt16) localPort
{
	return (_localAddress ? ntohs(((struct sockaddr_in*)_localAddress)->sin_port) : 0);//ntohs :将一个无符号短整形数从网络字节顺序转换为主机字节顺序
}
//返回本地的地址
- (UInt32) localIPv4Address
{
	return (_localAddress ? ((struct sockaddr_in*)_localAddress)->sin_addr.s_addr : 0);
}

- (NSString*) description
{
	return [NSString stringWithFormat:@"<%@ = 0x%08X | running = %i | local address = %@>", [self class], (long)self, [self isRunning], SockaddrToString(_localAddress)];
}

@end
